## Двоичные деревья поиска

Двоичные деревья обеспечивают быстрый поиск информации (O(log n)) и позволяют быстро добавлять и удалять информацию, буквально единичными операциями.

Ключевых отличий двоичного дерева поиска от [обычного](../01_SimpleTree/README.md) два:
1. Все данные в дереве хранятся в определённом образом упорядоченном виде;
2. Поиск выполняется с учётом этой упорядоченности. 

Операция поиска должна выдавать либо факт присутствия ключа в дереве, либо родительский узел, которому надо добавить новый узел в качестве потомка, и признак, каким этот узел добавляется - левым или правым. 

В данном учебном примере рассматриваеются **полностью упорядоченные** двоичные деревья, для которых соблюдается правило:        
*ключ левого потомка должен быть меньше ключа родителя, а ключ правого потомка должен быть больше ключа родителя*.

<img src="https://skillsmart.ru/algo/15-121-cm/tbin15.png" title="Ordered BST" width="400">

Поиск нужного узла происходит так: начиная с корня дерева, сравниваем ключ поиска с ключом текущего узла. Если ключ поиска меньше ключа текущего узла, переходим к левому узлу, иначе переходим к правому узлу. В итоге все сводится к двум ситуациям:
1. Мы добираемся до листа дерева с искомым значением.
2. Левый или правый потомок текущего узла отсутствует (значение не определено).

Результаты поиска требуется выдавать списком из трёх значений `[node, node_has_key, child_to_upd]`:
- `node`: узел, объект класса `BSTNode`);
- `node_has_key`: `true`, если этот узел содержит нужный ключ (иначе `false`);
- `child_to_upd`: если `node` является родительским узлом, и ему требуется создать новый узел, показывает, какому полю-потомку (левому или правому) родительского узла надо присвоить ссылку на новый узел.

Для хранения значений из списка будет создан отдельный класс `BSTFind`.


#### Описание классов, их полей и методов

Класс `BSTNode` - описывает узлы двоичного дерева:
- Конструктор `__init__(self, key, value, parent)` - создает узел с заданными параметрами.
- Поля:
    - `NodeKey` - идентификатор узла, по которому и происходит упорядочивание и поиск данных.
    - `NodeValue` - значение, хранимого в узле (default is None).
    - `Parent` - указатель на узел-родитель или None для корня.
    - `LeftChild` - левый потомок.
    - `RightChild` - правый потомок.

Класс `BSTFind` - вспомогательный, для создания методов работы с узлами в классе `BST`:
- Конструктор `__init__(self)`.
- Поля:
    - `Node` - указатель на текущий узел, с которым производится сравнение ключа.
    - `NodeHasKey` - индикатор совпадения ключа.
    - `ToLeft` - направление (лево/право), в которое следует поместить дочерний узел.

`BST`
- Конструктор `__init__(self, node)` - создает дерево c node в качестве корня.
- Поле `Root` - хранит ссылку на корневой узел.
- Методы:
    - `FindNodeByKey(self, key)`- поиск узла по значению ключа.            
    (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа).
    - `AddKeyValue(self, key, val)`- добавление нового узла с заданным ключом и соответствующим ему значение.           
    (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем)
    - `FinMinMax(self, FromNode, FindMax)` - поиск максимального и минимального ключей, начиная с заданного узла.         
    (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ)
    - `DeleteNodeByKey(self, key)` - удаление узла по его ключу.           
    (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода)
    - `Count(self)` - подсчет числа узлов в дереве.


## Распределение исходного кода по файлам проекта

[Двоичное дерево поиска](BST.py)

[Модульные тесты](BST_test.py)
